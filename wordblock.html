

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>타자 게임</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Babel for processing JSX in browser (No Build Mode) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map for React & GenAI -->
    <script type="importmap">
        {
          "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "@google/genai": "https://esm.sh/@google/genai@latest",
            "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
            "react/": "https://aistudiocdn.com/react@^19.2.0/"
          }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&display=swap');

        body {
            font-family: 'Jua', sans-serif;
            overscroll-behavior: none;
        }

        /* Animations and Utilities */
        .preserve-3d { transform-style: preserve-3d; }
        .perspective-1000 { perspective: 1000px; }

        @keyframes bounce-slow {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .animate-bounce-slow {
            animation: bounce-slow 3s infinite ease-in-out;
        }

        .cloud-bg {
            background-image: radial-gradient(circle, #ffffff 20%, transparent 20%),
            radial-gradient(circle, #ffffff 20%, transparent 20%);
            background-color: #F0F9FF;
            background-position: 0 0, 50px 50px;
            background-size: 100px 100px;
            animation: moveBackground 20s linear infinite;
        }
        @keyframes moveBackground {
            0% { background-position: 0 0, 50px 50px; }
            100% { background-position: 100px 100px, 150px 150px; }
        }
    </style>

    <!--
      [서버 배포 설정]
      아래 스크립트 태그 안에 발급받은 Google Gemini API 키를 입력해주세요.
    -->
    <script>
        window.GEMINI_API_KEY = "여기에_API_KEY를_입력하세요";
    </script>
</head>
<body class="bg-sky-50 text-slate-800 overflow-hidden m-0 p-0 select-none touch-none">
<div id="root"></div>

<!-- Main Game Script -->
<script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef } from 'react';
    import ReactDOM from 'react-dom/client';
    import { GoogleGenAI } from "@google/genai";

    // --- 1. Constants & Types (Merged) ---
    const GameState = {
        MENU: 'MENU',
        PLAYING: 'PLAYING',
        GAME_OVER: 'GAME_OVER'
    };

    const WordCategory = {
        ANIMALS: '동물',
        FOOD: '음식',
        SCHOOL: '학교',
        NATURE: '자연',
        MIXED: '종합'
    };

    const COLORS = [
        "bg-orange-400 border-orange-500",
        "bg-green-400 border-green-500",
        "bg-sky-400 border-sky-500",
        "bg-pink-400 border-pink-500",
        "bg-yellow-400 border-yellow-500"
    ];

    const FALLBACK_WORDS = [
        "사과", "바나나", "당근", "호랑이", "학교", "친구", "사랑", "하늘",
        "구름", "바다", "강아지", "고양이", "컴퓨터", "키보드", "마우스",
        "노래", "춤", "피아노", "축구", "야구", "여름", "겨울", "눈사람"
    ];

    const GAME_CONFIG = {
        WIDTH_PERCENT: 100,
        HEIGHT_PERCENT: 100,
        SPAWN_RATE_BASE: 2000,
        SPEED_BASE: 0.12,
        WORDS_PER_LEVEL: 5,
        INITIAL_LIVES: 5
    };

    // --- 2. Services (Merged) ---
    const shuffle = (array) => {
        let currentIndex = array.length, randomIndex;
        while (currentIndex !== 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    };

    const fetchWordsFromGemini = async (topic, count = 20) => {
        const apiKey = window.GEMINI_API_KEY;

        // If no key, return fallback immediately
        if (!apiKey || apiKey.includes("여기에")) {
            console.warn("No Valid API Key found, using fallback words.");
            return shuffle([...FALLBACK_WORDS]);
        }

        try {
            const ai = new GoogleGenAI({ apiKey: apiKey });
            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: `Generate ${count} single, distinct, Korean nouns related to the topic "${topic}". The words should be suitable for a typing game for children (simple words, no spaces, length between 2 and 6 characters). Return only the words in a JSON array.`,
                config: {
                    responseMimeType: "application/json",
                }
            });

            const jsonText = response.text; // Fixed: access property directly
            if (!jsonText) return shuffle([...FALLBACK_WORDS]);

            const parsed = JSON.parse(jsonText);
            // Handle both { words: [...] } and straight array [...]
            const wordsArray = Array.isArray(parsed) ? parsed : (parsed.words || []);

            if (Array.isArray(wordsArray)) {
                const sanitized = wordsArray
                .map(w => typeof w === 'string' ? w.replace(/[^가-힣]/g, '') : '')
                .filter(w => w.length > 0);
                return sanitized.length > 0 ? sanitized : shuffle([...FALLBACK_WORDS]);
            }

            return shuffle([...FALLBACK_WORDS]);
        } catch (error) {
            console.error("Gemini API Error:", error);
            return shuffle([...FALLBACK_WORDS]);
        }
    };

    // --- 3. Components ---

    // Tadaki Character
    const Tadaki = ({ emotion, className }) => {
        const [blink, setBlink] = useState(false);

        useEffect(() => {
            const interval = setInterval(() => {
                setBlink(true);
                setTimeout(() => setBlink(false), 150);
            }, 3000 + Math.random() * 2000);
            return () => clearInterval(interval);
        }, []);

        const getAnimation = () => {
            switch (emotion) {
                case 'win': return 'animate-bounce';
                case 'typing': return 'translate-y-1';
                case 'sad': return 'translate-y-2 rotate-6';
                default: return 'animate-bounce-slow';
            }
        };

        return (
            <div className={`relative ${className} ${getAnimation()} transition-transform duration-300`}>
                <svg viewBox="0 0 200 240" className="w-full h-full drop-shadow-xl overflow-visible">
                    <defs>
                        <linearGradient id="eyeGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stopColor="#0EA5E9" />
                            <stop offset="100%" stopColor="#0369A1" />
                        </linearGradient>
                        <linearGradient id="hoodGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stopColor="#22D3EE" />
                            <stop offset="100%" stopColor="#0891B2" />
                        </linearGradient>
                    </defs>
                    <path d="M55 170 L55 215 Q55 235 75 235 L125 235 Q145 235 145 215 L145 170 Z" fill="url(#hoodGradient)" />
                    <path d="M55 180 Q35 200 45 215" stroke="#0891B2" strokeWidth="14" strokeLinecap="round" fill="none" />
                    <path d="M145 180 Q165 200 155 215" stroke="#0891B2" strokeWidth="14" strokeLinecap="round" fill="none" />
                    <rect x="50" y="205" width="100" height="12" rx="2" fill="#334155" />
                    <rect x="90" y="203" width="20" height="16" rx="3" fill="none" stroke="#FBBF24" strokeWidth="3" />
                    <line x1="103" y1="206" x2="103" y2="216" stroke="#FBBF24" strokeWidth="2" />
                    <line x1="100" y1="160" x2="100" y2="205" stroke="#FBBF24" strokeWidth="3" strokeDasharray="4 2" />
                    <rect x="97" y="155" width="6" height="8" fill="#FBBF24" />
                    <circle cx="100" cy="100" r="75" fill="url(#hoodGradient)" />
                    <path d="M160 60 Q175 50 180 40" stroke="#0891B2" strokeWidth="4" fill="none" />
                    <circle cx="180" cy="40" r="8" fill="#22D3EE" />
                    <circle cx="178" cy="38" r="3" fill="white" opacity="0.5" />
                    <circle cx="35" cy="100" r="15" fill="#22D3EE" />
                    <circle cx="165" cy="100" r="15" fill="#22D3EE" />
                    <path d="M50 100 Q50 55 100 55 Q150 55 150 100 Q150 145 100 145 Q50 145 50 100 Z" fill="#FFF1F2" />
                    <path d="M55 80 Q80 100 120 60" stroke="#334155" strokeWidth="0" fill="#334155" opacity="0.8" />
                    <path d="M52 95 C 60 70, 90 65, 140 80 C 130 50, 90 50, 60 65 Z" fill="#1E293B" />
                    <circle cx="60" cy="115" r="6" fill="#FDA4AF" opacity="0.5" />
                    <circle cx="140" cy="115" r="6" fill="#FDA4AF" opacity="0.5" />
                    {emotion === 'sad' ? (
                        <>
                            <path d="M65 105 Q75 95 85 105" stroke="#0F172A" strokeWidth="4" fill="none" />
                            <path d="M115 105 Q125 95 135 105" stroke="#0F172A" strokeWidth="4" fill="none" />
                            <circle cx="60" cy="125" r="3" fill="#60A5FA" className="animate-ping" />
                        </>
                    ) : (
                        <>
                            {blink ? (
                                <>
                                    <path d="M70 105 Q80 110 90 105" stroke="#0F172A" strokeWidth="3" fill="none" />
                                    <path d="M110 105 Q120 110 130 105" stroke="#0F172A" strokeWidth="3" fill="none" />
                                </>
                            ) : (
                                <>
                                    <ellipse cx="80" cy="105" rx="14" ry="16" fill="url(#eyeGradient)" />
                                    <ellipse cx="80" cy="105" rx="14" ry="16" stroke="#0F172A" strokeWidth="1.5" fill="none" />
                                    <circle cx="85" cy="98" r="4" fill="white" />
                                    <circle cx="76" cy="110" r="2" fill="white" opacity="0.7" />
                                    <ellipse cx="120" cy="105" rx="14" ry="16" fill="url(#eyeGradient)" />
                                    <ellipse cx="120" cy="105" rx="14" ry="16" stroke="#0F172A" strokeWidth="1.5" fill="none" />
                                    <circle cx="125" cy="98" r="4" fill="white" />
                                    <circle cx="116" cy="110" r="2" fill="white" opacity="0.7" />
                                </>
                            )}
                        </>
                    )}
                    <circle cx="100" cy="118" r="2" fill="#B45309" />
                    {emotion === 'happy' || emotion === 'win' ? (
                        <path d="M92 125 Q100 132 108 125" stroke="#0F172A" strokeWidth="2.5" fill="none" strokeLinecap="round" />
                    ) : emotion === 'sad' ? (
                        <path d="M92 130 Q100 122 108 130" stroke="#0F172A" strokeWidth="2.5" fill="none" strokeLinecap="round" />
                    ) : emotion === 'typing' ? (
                        <circle cx="100" cy="128" r="3" fill="#0F172A" />
                    ) : (
                        <path d="M95 128 Q100 130 105 128" stroke="#0F172A" strokeWidth="2.5" fill="none" strokeLinecap="round" />
                    )}
                </svg>
            </div>
        );
    };

    // Menu Component
    const Menu = ({ onStart, highScore }) => {
        return (
            <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-sky-50 overflow-hidden">
                <div className="absolute top-10 left-10 text-6xl opacity-20 animate-bounce-slow">☁️</div>
                <div className="absolute bottom-20 right-20 text-6xl opacity-20 animate-bounce-slow" style={{ animationDelay: '1s' }}>⭐</div>
                <div className="absolute top-1/3 right-10 text-5xl opacity-20 animate-bounce-slow" style={{ animationDelay: '2s' }}>✨</div>

                <div className="relative bg-white p-10 pt-16 rounded-[3rem] border-b-8 border-sky-200 shadow-2xl max-w-2xl w-full mx-4 flex flex-col items-center text-center animate-bounce-slow">
                    <div className="absolute -top-32 transform hover:scale-110 transition-transform cursor-pointer">
                        <Tadaki emotion="happy" className="w-64 h-64" />
                    </div>

                    <h1 className="mt-24 text-6xl font-black text-sky-500 drop-shadow-sm tracking-tight mb-2">
                        블럭타자게임
                    </h1>
                    <p className="text-slate-500 text-lg font-bold mb-8">타닥이와 함께 단어 여행을 떠나요!</p>

                    <div className="bg-yellow-50 rounded-2xl px-8 py-4 mb-8 border-2 border-yellow-200 w-full max-w-xs relative overflow-hidden">
                        <div className="absolute -right-4 -top-4 opacity-20">
                            <Tadaki emotion="idle" className="w-24 h-24" />
                        </div>
                        <span className="text-yellow-600 font-bold text-sm uppercase block mb-1">최고 기록</span>
                        <div className="text-4xl font-black text-yellow-500 relative z-10">{highScore} 점</div>
                    </div>

                    <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 w-full">
                        {Object.values(WordCategory).map((cat) => (
                            <button
                                key={cat}
                                onClick={() => onStart(cat)}
                                className="group relative h-16 outline-none"
                            >
                                <div className="absolute inset-0 bg-sky-200 rounded-xl transform translate-y-2 transition-transform group-hover:translate-y-3 group-active:translate-y-2"></div>
                                <div className="absolute inset-0 bg-white border-2 border-sky-400 rounded-xl flex items-center justify-center transform transition-transform group-hover:-translate-y-1 group-active:translate-y-1">
					   <span className="text-sky-500 font-black text-xl group-hover:scale-110 transition-transform">
						  {cat}
					   </span>
                                </div>
                            </button>
                        ))}
                    </div>
                </div>


            </div>
        );
    };

    // GameCanvas Component
    const GameCanvas = ({ gameState, setGameState, category, updateScore, finalScore }) => {
        const [words, setWords] = useState([]);
        const [inputValue, setInputValue] = useState('');
        const [score, setScore] = useState(0);
        const [level, setLevel] = useState(1);
        const [lives, setLives] = useState(GAME_CONFIG.INITIAL_LIVES);
        const [successCount, setSuccessCount] = useState(0);
        const [isLoading, setIsLoading] = useState(false);
        const [showCopyFeedback, setShowCopyFeedback] = useState(false);
        const [tadakiEmotion, setTadakiEmotion] = useState('idle');

        const gameStateRef = useRef(gameState);
        const levelRef = useRef(level);
        const wordPoolRef = useRef([]);
        const lastSpawnTime = useRef(0);
        const requestRef = useRef(0);
        const inputRef = useRef(null);

        useEffect(() => { gameStateRef.current = gameState; }, [gameState]);
        useEffect(() => { levelRef.current = level; }, [level]);

        useEffect(() => {
            if (gameState === GameState.PLAYING) {
                initializeGame();
            } else {
                if (requestRef.current) cancelAnimationFrame(requestRef.current);
            }
        }, [gameState]);

        // Sound System
        const playSound = (type) => {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                const now = ctx.currentTime;

                if (type === 'type') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, now);
                    osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                } else if (type === 'success') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(523.25, now);
                    osc.frequency.setValueAtTime(659.25, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                } else if (type === 'clear') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                } else if (type === 'levelup') {
                    osc.type = 'square';
                    gain.gain.value = 0.05;
                    osc.frequency.setValueAtTime(523.25, now);
                    osc.frequency.setValueAtTime(659.25, now + 0.1);
                    osc.frequency.setValueAtTime(783.99, now + 0.2);
                    osc.frequency.setValueAtTime(1046.50, now + 0.3);
                    gain.gain.linearRampToValueAtTime(0, now + 0.6);
                    osc.start(now);
                    osc.stop(now + 0.6);
                } else if (type === 'gameover') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 1);
                    osc.start(now);
                    osc.stop(now + 1);
                }
            } catch (e) {}
        };

        const loadWords = async () => {
            setIsLoading(true);
            try {
                const newWords = await fetchWordsFromGemini(category, 30);
                wordPoolRef.current = newWords;
            } catch (e) {
                console.error("Failed to load words", e);
            }
            setIsLoading(false);
        };

        const initializeGame = async () => {
            setScore(0);
            setLevel(1);
            setSuccessCount(0);
            setLives(GAME_CONFIG.INITIAL_LIVES);
            setWords([]);
            setInputValue('');
            updateScore(0);
            setTadakiEmotion('idle');
            wordPoolRef.current = [];
            setShowCopyFeedback(false);
            await loadWords();
            if (inputRef.current) inputRef.current.focus();
            lastSpawnTime.current = performance.now();
            if (requestRef.current) cancelAnimationFrame(requestRef.current);
            requestRef.current = requestAnimationFrame(gameLoop);
        };

        const spawnWord = () => {
            const pool = wordPoolRef.current;
            if (pool.length === 0) {
                if (!isLoading) {
                    fetchWordsFromGemini(category, 20).then(w => {
                        wordPoolRef.current = [...wordPoolRef.current, ...w];
                    });
                }
                return;
            }
            const randomIndex = Math.floor(Math.random() * pool.length);
            const wordText = pool[randomIndex];
            const randomX = Math.random() * 80 + 5;
            const randomColor = COLORS[Math.floor(Math.random() * COLORS.length)];

            const newWord = {
                id: Math.random().toString(36).substr(2, 9),
                text: wordText,
                x: randomX,
                y: -20,
                speed: GAME_CONFIG.SPEED_BASE + (Math.random() * 0.05),
                color: randomColor,
                isHit: false
            };
            setWords(prev => [...prev, newWord]);
        };

        const gameLoop = (time) => {
            if (gameStateRef.current !== GameState.PLAYING) return;
            const currentLevel = levelRef.current;
            const spawnRate = Math.max(600, GAME_CONFIG.SPAWN_RATE_BASE - (currentLevel * 250));

            if (time - lastSpawnTime.current > spawnRate) {
                spawnWord();
                lastSpawnTime.current = time;
            }

            setWords(prevWords => {
                const nextWords = [];
                let livesLost = 0;

                prevWords.forEach(word => {
                    if (word.isHit) return;
                    const speedMultiplier = 1 + (currentLevel * 0.25);
                    const nextY = word.y + (word.speed * speedMultiplier);
                    if (nextY > 110) {
                        livesLost++;
                    } else {
                        nextWords.push({ ...word, y: nextY });
                    }
                });

                if (livesLost > 0) {
                    setLives(prev => {
                        const newLives = prev - livesLost;
                        setTadakiEmotion('sad');
                        setTimeout(() => setTadakiEmotion('idle'), 1000);
                        if (newLives <= 0) {
                            setTimeout(() => {
                                playSound('gameover');
                                setGameState(GameState.GAME_OVER);
                            }, 0);
                        }
                        return newLives;
                    });
                }
                return nextWords;
            });
            requestRef.current = requestAnimationFrame(gameLoop);
        };

        const handleInputChange = (e) => {
            const val = e.target.value.trim();
            setInputValue(val);
            if (val.length > 0 && val.length > inputValue.length) {
                playSound('type');
                setTadakiEmotion('typing');
                setTimeout(() => setTadakiEmotion('idle'), 500);
            }
        };

        const handleKeyDown = (e) => {
            if (gameState !== GameState.PLAYING) return;
            if (e.code === 'Space') {
                e.preventDefault();
                setInputValue('');
                playSound('clear');
                return;
            }
            if (e.key === 'Enter') {
                if (e.nativeEvent.isComposing) return;
                checkMatchAndSubmit();
            }
        };

        const checkMatchAndSubmit = () => {
            const val = inputValue;
            if (!val) return;
            const matches = words.filter(w => w.text === val && !w.isHit && w.y < 95);
            if (matches.length > 0) {
                const target = matches.sort((a, b) => b.y - a.y)[0];
                const points = 10 * levelRef.current;
                setScore(prev => {
                    const newScore = prev + points;
                    updateScore(newScore);
                    return newScore;
                });
                playSound('success');
                setInputValue('');
                setTadakiEmotion('win');
                setTimeout(() => setTadakiEmotion('idle'), 800);
                setWords(prev => prev.filter(w => w.id !== target.id));
                setSuccessCount(prev => {
                    const newCount = prev + 1;
                    if (newCount % GAME_CONFIG.WORDS_PER_LEVEL === 0) {
                        playSound('levelup');
                        setLevel(l => l + 1);
                    }
                    return newCount;
                });
            }
        };

        const handleShare = async () => {
            const shareUrl = "https://";
            const shareData = {
                title: '블럭타자게임',
                text: `...와 함께하는 즐거운 타자연습! 제 점수는 ${finalScore}점이에요. 함께 도전해요!`,
                url: shareUrl
            };
            try {
                if (navigator.share && navigator.canShare(shareData)) {
                    await navigator.share(shareData);
                } else {
                    await navigator.clipboard.writeText(shareUrl);
                    setShowCopyFeedback(true);
                    setTimeout(() => setShowCopyFeedback(false), 2000);
                }
            } catch (e) { console.error('Share failed', e); }
        };

        const handleBlur = () => {
            if (gameState === GameState.PLAYING) {
                requestAnimationFrame(() => inputRef.current?.focus());
            }
        };

        return (
            <div className="relative w-full h-full overflow-hidden bg-sky-50 font-sans">
                <div className="absolute inset-0 cloud-bg opacity-50 pointer-events-none"></div>
                <div className="absolute top-0 left-0 right-0 p-6 flex justify-between items-start z-50 pointer-events-none select-none">
                    <div className="flex gap-4">
                        <div className="bg-white rounded-2xl p-3 border-b-4 border-sky-200 shadow-md min-w-[120px]">
                            <div className="text-xs font-bold text-sky-400 uppercase tracking-wider">점수</div>
                            <div className="text-3xl font-black text-slate-700">{score}</div>
                        </div>
                        <div className="bg-white rounded-2xl p-3 border-b-4 border-yellow-200 shadow-md min-w-[100px]">
                            <div className="text-xs font-bold text-yellow-400 uppercase tracking-wider">레벨</div>
                            <div className="text-3xl font-black text-slate-700">{level}</div>
                        </div>
                    </div>
                    <div className="flex space-x-1 bg-white/60 p-2 rounded-full border-2 border-red-100">
                        {Array.from({ length: 5 }).map((_, i) => (
                            <span key={i} className={`text-2xl transition-all duration-300 ${i < lives ? 'scale-100 opacity-100' : 'scale-75 opacity-20 grayscale'}`}>❤️</span>
                        ))}
                    </div>
                </div>

                {isLoading && words.length === 0 && (
                    <div className="absolute inset-0 flex items-center justify-center z-40">
                        <div className="bg-white p-8 rounded-[2rem] shadow-xl flex flex-col items-center animate-bounce">
                            <Tadaki emotion="idle" className="w-32 h-32 mb-4" />
                            <span className="text-sky-500 font-bold text-xl">단어를 심는 중...</span>
                        </div>
                    </div>
                )}

                <div className="absolute inset-0 pointer-events-none">
                    {words.map(word => (
                        <div key={word.id} className="absolute transition-transform will-change-transform" style={{ left: `${word.x}%`, top: `${word.y}%`, zIndex: 10 }}>
                            <div className={`relative px-6 py-3 ${word.color} border-b-4 text-white text-2xl font-bold rounded-full shadow-lg transform transition-all flex items-center justify-center min-w-[100px] ${inputValue.length > 0 && word.text.startsWith(inputValue) ? 'scale-110 ring-4 ring-white' : ''}`}>
					  <span className="drop-shadow-md">
						{word.text.split('').map((char, idx) => (
                            <span key={idx} className={idx < inputValue.length && word.text.startsWith(inputValue) ? 'text-yellow-200' : 'text-white'}>{char}</span>
                        ))}
					  </span>
                                <div className="absolute top-1 right-4 w-3 h-1 bg-white/40 rounded-full"></div>
                            </div>
                        </div>
                    ))}
                </div>

                <div className="absolute bottom-0 left-0 right-0 h-48 bg-gradient-to-t from-sky-100/90 to-transparent z-40 flex items-end justify-center pb-12">
                    <div className="relative w-full max-w-2xl mx-4 flex items-end gap-4">
                        <div className="relative z-50 -mb-4">
                            <div className="w-32 h-32 filter drop-shadow-lg transform transition-transform">
                                <Tadaki emotion={tadakiEmotion} className="w-full h-full" />
                            </div>
                        </div>
                        <div className="flex-1 relative">
                            <div className="absolute left-[-10px] bottom-8 w-6 h-6 bg-white transform rotate-45 border-l-4 border-b-4 border-sky-200 z-0"></div>
                            <div className={`relative z-10 w-full h-20 bg-white border-4 ${inputValue ? 'border-sky-400' : 'border-sky-200'} rounded-[2rem] rounded-bl-none flex items-center px-8 shadow-xl transform transition-all ${inputValue ? 'scale-[1.02]' : 'scale-100'}`}>
						 <span className="text-4xl font-black text-slate-700 tracking-wide min-h-[2.5rem] w-full text-left">
						   {inputValue}<span className="animate-pulse inline-block w-1 h-8 bg-sky-500 ml-1 align-middle"></span>
						 </span>
                            </div>
                            <input ref={inputRef} type="text" value={inputValue} onChange={handleInputChange} onKeyDown={handleKeyDown} onBlur={handleBlur} className="absolute inset-0 opacity-0 cursor-none w-full h-full z-50" autoFocus />
                            <div className="absolute -bottom-8 left-0 text-sky-400 font-bold text-sm pl-4">Space: 지우기 | Enter: 입력</div>
                        </div>
                    </div>
                </div>

                {gameState === GameState.GAME_OVER && (
                    <div className="absolute inset-0 z-[100] flex flex-col items-center justify-center bg-black/20 backdrop-blur-sm">
                        <div className="bg-white p-12 rounded-[3rem] shadow-2xl text-center border-b-8 border-slate-200 transform transition-all animate-bounce-slow relative max-w-lg w-full mx-4">
                            <div className="absolute -top-20 left-1/2 transform -translate-x-1/2">
                                <Tadaki emotion="happy" className="w-40 h-40" />
                            </div>
                            <h2 className="text-5xl font-black text-slate-800 mb-2 mt-12">게임 종료!</h2>
                            <p className="text-slate-400 font-bold mb-8">다시도전해보세요!</p>
                            <div className="bg-sky-50 rounded-2xl p-6 mb-8 border-2 border-sky-100">
                                <div className="text-sky-400 text-xs font-bold uppercase tracking-widest mb-1">최종 점수</div>
                                <div className="text-6xl font-black text-sky-500">{finalScore}</div>
                            </div>
                            <div className="flex flex-col sm:flex-row gap-4 justify-center items-center w-full">
                                <button onClick={() => setGameState(GameState.MENU)} className="w-full sm:w-auto flex-1 bg-green-500 hover:bg-green-600 text-white text-xl font-bold py-4 px-6 rounded-full shadow-lg hover:shadow-xl hover:-translate-y-1 transition-all border-b-4 border-green-700 active:border-b-0 active:translate-y-1 whitespace-nowrap">다시 시작하기</button>
                                <button onClick={handleShare} className="w-full sm:w-auto flex-1 bg-yellow-400 hover:bg-yellow-500 text-white text-xl font-bold py-4 px-6 rounded-full shadow-lg hover:shadow-xl hover:-translate-y-1 transition-all border-b-4 border-yellow-600 active:border-b-0 active:translate-y-1 relative whitespace-nowrap">친구에게 공유 {showCopyFeedback && <div className="absolute -top-12 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white text-xs py-2 px-3 rounded-lg whitespace-nowrap animate-bounce z-50">주소 복사 완료!<div className="absolute bottom-[-4px] left-1/2 transform -translate-x-1/2 w-2 h-2 bg-slate-800 rotate-45"></div></div>}</button>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        );
    };

    // App Component
    const App = () => {
        const [gameState, setGameState] = useState(GameState.MENU);
        const [category, setCategory] = useState(WordCategory.MIXED);
        const [score, setScore] = useState(0);
        const [highScore, setHighScore] = useState(0);

        useEffect(() => {
            const saved = localStorage.getItem('cybertype_highscore');
            if (saved) setHighScore(parseInt(saved, 10));
        }, []);

        const updateHighScore = (newScore) => {
            if (newScore > highScore) {
                setHighScore(newScore);
                localStorage.setItem('cybertype_highscore', newScore.toString());
            }
        };

        const handleStart = (selectedCategory) => {
            setCategory(selectedCategory);
            setGameState(GameState.PLAYING);
        };

        return (
            <div className="w-screen h-screen bg-slate-900 overflow-hidden relative">
                <div className="absolute inset-0 bg-[radial-gradient(ellipse_at_center,_var(--tw-gradient-stops))] from-slate-800 via-slate-900 to-black"></div>
                {gameState === GameState.MENU && <Menu onStart={handleStart} highScore={highScore} />}
                {(gameState === GameState.PLAYING || gameState === GameState.GAME_OVER) && (
                    <GameCanvas gameState={gameState} setGameState={(state) => { setGameState(state); if (state === GameState.GAME_OVER) { updateHighScore(score); } }} category={category} updateScore={setScore} finalScore={score} />
                )}
            </div>
        );
    };

    // Mount
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>
</body>
</html>
